`#!/bin/sh `

脚本文件的顶行，告诉系统，应该去哪里用哪个解释器执行该脚本；

但如果该脚本不是直接执行，而是作为参数传递给某个解释器，如：

`/bin/sh xxx.sh`，那，文件顶头的 `#!` 声明就会被忽视，毕竟已经明确指定解释器了。

`echo 'hello'`

echo 命令用于向窗口输出文本

`xxx='dasu'` 

用 `key=value` 形式定义变量，`=` 号两边不能有空格

`$xxx 或 ${xxx}`

变量名前加个 `$` 使用变量

`'dasu'` `"dasu"` `dasu` 

单引号、双引号、甚至不加引号都会被作为字符串使用

单引号里的字符串不做任何处理工作，是什么就原样输出

双引号里如果有表达式、有变量，会先进行处理，最后再输出，所以字符串的拼接，可以放在双引号内

`${#xxx}` 

用来获取字符串长度

`${xxx:1:2}`

用来截取子字符串

``i=`expr index "$xxx" x` ``

用来查找子字符，expr 表示接下去要执行个内置方法，方法名是 index，接收两个参数：原字符串，查找的字符

注意，只找字符，不是找子字符串

``echo `pwd` `` `$(pwd)`

\` 反引号内部是一个表达式，`$()` 美元符合加小括号形式，括号内也是一个表达式

注意，表达式计算后的值，会被作为命令继续被执行

所以，当命令是需要通过拼接、读取参数等处理后才生成的，那么就可以将这些处理操作放置在 \` 反引号内部，这样，命令生成后，才会去执行

`#xxxx`

单个 `#` 用来注释后面内容

`$1-9` 

读取参数，参数可以是执行脚本时传递的参数，也可以是执行方法时传递的参数

`$1` 表示第一个参数，以此类推

`$*` 输出所有参数

`$0` 输出脚本文件名

所以，脚本内部开始，可以用 `echo $0 $*` 来输出外部使用该脚本时，传递的参数

`$?` 表示上个命令的执行后的退出状态， 0 表示没有错误，其他值表示有错误，脚本如期结束时，脚本内最后应该 exit 0 来退出命令。

```bash
if [ -n "$1" ]; then
  echo "true"
else
  echo "false"
fi
```

注意，中括号内部两侧需要有空格。

判断语句，其中，一些常见的判断如下：

- 判断字符串相等

```bash
if [[ $1=$2 ]]; then
  echo "true"
else
  echo "false"
fi
```

- 判断文件是否存在

```bash
if [ -e $1 ]; then
  echo "true"
else
  echo "false"
fi
```

- 判断是否是目录

```bash
if [ -d $1 ]; then
  echo "true"
else
  echo "false"
fi
```

-o 或运算，相当于 ||

-a 与运算，相当于 &&

-z 字符串长度是否为 0，为 0 返回 true

-n 字符串长度是否为 0，不为 0 返回 true

-f 检测文件是否是普通文件（既不是目录，也不是设备文件）

-r 检测文件是否可读

-w 检测文件是否可写

-x 检测文件是否可执行

-s 检测文件是否为空

-e 检测文件是否存在

-d 检测文件是否是目录

test 命令检测某个条件是否成立

-eq 等于 =

-ne 不等于 !=

-gt 大于 >

-lt 小于 <

-le 小于等于 <=



```
if []; then

elif [] then

else

fi
```





### 运算符

因为 bash 不支持数学运算，如下的写法都是错误的：

```
a=2+2
echo $a # 输出 2+2，整个作为字符串

a=`2+2` # 2+2：command not found，整个被作为命令执行
a=`2 + 2` # 2：command not found，每个字符都被作为命令执行
```

想要进行一些运算，需要借助其他命令，如 awk、expr、$[]

### expr

expr 后面跟随的表达式，就可以像其他语言一样，被正常的进行运算，如：

```bash
echo `expr 2 + 2` # 4
```

另外，expr 后面跟随的运算表达式，运算符前后需要有空格，否则 2+2 这种会被作为字符串看待

当借助 expr 命令，就可以正常的进行加减乘除的基本数学运算了



### $[]

```bash
a=$[2+2]
echo $a # 4
```





- echo -e 开启转义， \n 会换行

输出想要格式化的话，用 printf 命令



- `read xxx`

从标准输入中读取一行，并赋值给 xxx 变量





### for 循环

```bash
for loop in 1 3 4 5 6
do

done
```

### 函数

```bash
add(){
	echo $0 $1 $2
}
```

### 输入输出重定向

默认的输入输出都是终端，但可通过 > < 来进行修改，比如

ls > file

将输出写入到文件中，覆盖写入

ls >> file

将输出写入到文件中，追加写入

xxx.sh < file

本来是从键盘输入到终端，转移到从文件读取内容

xxx.sh<<EOF

EOF

将两个 EOF 之间的内容作为输入

ls > /dev/null

如果希望执行某个命令，但又不希望在屏幕上显示，那么可以将输出重定向到 /dev/null

写入 /dev/null 中的内容会被丢弃



### 执行其他脚本文件

shell 脚本内可以执行其他脚本文件，方式有两种：

```bash
. filename # 注意点号 . 和文件名中间有空格

#或者

source filename
```





### ssh

远程连接工具

` ssh user@ip -p 10024 `



### scp

远程拷贝，一般六种用法：

- 把远程文件复制到本地

` scp root@www.test.com:/val/test/test.tar.gz /val/test/test.tar.gz `

- 把本地文件复制到远程

` scp /val/test.tar.gz root@www.test.com:/val/test.tar.gz `



### expect



